---
output: html_document
---

\br
\br

# Tarea 1

<ul>
  <big>
  <li>Casandra Sofía Pejcovich</li>
  <li>Carlos Luna Hernández</li>
  <li>Aldo Enrique Chong Valentín </li>
  <li>Luis Fernando Apáez Álvarez</li>
  
  </big>
</ul>

\br
\br

## Índice
<ul>
  <a href="#p1"><li>Pregunta 1</li></a>
  <ul>
    <a href="#ia"><li>Inciso a)</li></a>
    <a href="#ib"><li>Inciso b)</li></a>
    <a href="#ic"><li>Inciso c)</li></a>
    <a href="#id"><li>Inciso d)</li></a>
    <a href="#id"><li>Inciso e)</li></a>
    <a href="#if"><li>Inciso f)</li></a>
    <a href="#ig"><li>Inciso g)</li></a>
  </ul>
  <a href="#p2"><li>Pregunta 2</li></a>
  <a href="#p3"><li>Pregunta 3</li></a>
</ul>

\br
\br

## Pregunta 1: Trabajar con el dataset **planes** de la librería **nycflights13**: <a id="p1"></a>

Comenzaremos por llamar a las librerías necesarias

```{r message=FALSE, warning=FALSE}
inst_dplyr <- require('dplyr')
inst_ggplot2 <- require('ggplot2')
inst_nycflights13 <- require('nycflights13')
```

procedemos a revisar que los paquetes estén cargados correctamente

```{r}
inst_correcta <- c(inst_dplyr, inst_ggplot2, inst_nycflights13)
inst_correcta
```

y revisamos que los paquetes estén en nuestra lista de búsqueda actual

```{r}
search()
```

Ahora bien, pasemos a resolver cada uno de los incisos de este primer ejercicio:

### Inciso _a)_ <a id="ia"></a>

EL número de columnas que tiene la tabla está dado por el número

```{r}
col_planes <- ncol(planes)
print(paste("Número de columnas:", col_planes))
```

luego, para conocer el número de registro multiplicamos el número de filas por el número de columnas

```{r}
# Conocemos primero el número de filas
row_planes <- nrow(planes)

# Calculamos
num_registros <- col_planes * row_planes
print(paste("El número de registros es de:", num_registros))
```

### Inciso b) <a id="ib"></a>

Asignamos a cada vector la descripción de la variable en cada columna

```{r}
col_1 <- "el número de cola (tail number)"
col_2 <- "el año de fabricaciÃ³n (year manufactured)"
col_3 <- "el tipo de avión (type of plane)"
col_4 <- "el fabricante (manufacturer)"
col_5 <- "el modelo (model)"
col_6 <- "el número de motores (number of engines)"
col_7 <- "el número de asientos (number of seats)"
col_8 <- "la velocidad crucero promedio en millas por hora (average crusing speed in mph)"
col_9 <- "el tipo de motor (type of engine)"
```

Concatenamos por fila los vectores anteriores en una matriz que podamos mandar llamar

```{r}
matriz_desc <- rbind(col_1,col_2,col_3,col_4,col_5,col_6,col_7,col_8,col_9)
matriz_desc
```

y creamos una lista con los tipos de datos

```{r}
tipodato_col <- lapply(planes, class)
tipodato_col
```


Después, creamos una función que concatene texto y los datos: numero de columna, nombre de la columna del dataframe planes, descripcion de los valores que almacena y tipo de dato que contiene; para cada una de las 9 columnas

```{r eval=FALSE}
fun1 <- function() {
  for (i in 1:col_planes) {
    print(paste("Col",i,":","'",colnames(planes)[i],"'","representa",matriz_desc[i],"y es 
                de tipo",tipodato_col[i]))
  }
}

fun1()
```

### Inciso c) <a id="ic"></a>

Comenzamos creando un factor de la columna Manufacturer del dataframe ``planes``

```{r}
planes_factor <- factor(planes$manufacturer)
```

Gracias a la estructura de los factores, podemos hallar los registros distintos entre el total de filas con


```{r}
levels(planes_factor)
```

Luego, comprobamos que lo anterior es un vector de longitud ``[1:35]``

```{r}
str(levels(planes_factor))
```

De nuevo, aprovechando la creaciÃ³n del vector, usamos función ``summary`` para contabilizar el número de registros por nivel

```{r}
summary(planes_factor)
```


Comprobamos que lo anterior también es un vector de long ``[1:35]``

```{r}
str(summary(planes_factor))
```

Creamos un dataframe (tibble) que se alimente de los niveles y del número de registros por cada uno de estos

```{r}
planes_tibble <- tibble(m = levels(planes_factor), r = summary(planes_factor))
planes_tibble
```

Guardamos en una variable, el tibble organizado de manera descendiente sobre los registros

```{r}
planes_desc <- arrange(planes_tibble, desc(r))
planes_desc
```


Creamos un nuevo tibble que sólo tome las primeras 3 filas del tibble anterior en orden descendiente


```{r}
gg_tibble <- tibble(Fa = planes_desc$m[c(1,2,3)], Registros = planes_desc$r[c(1,2,3)])
```

Asignamos a un vector el "orden descendiente" por medio de la función ``levels`` aplicada sobre un factor

```{r}
Fabricantes <- factor(gg_tibble$Fa, level =  planes_desc$m[c(1,2,3)])

# Creamos el vector que almacena los colores para la grafica

colors <- c("#845EC2", "#D65DB1","#FF9671")
```

Graficamos un barplot con las tres manufactureras con más sregistros en la tabla, en orden descendente

```{r}
ggplot( data = gg_tibble, mapping = aes(x= Fabricantes, y = Registros)) +
  geom_bar(stat = "identity", fill = colors)
```


### Inciso d) <a id="id"></a>

Comenzamos por filtrar los datos por año hasta 1983

```{r}
# Filtro:
filter1 <- planes %>%
  filter(year <= 1983)

# Imprimimos nuestro nuevo dataset
filter1

```

Generamos el diagrama boxplot que toma valores del dataframe con años de fabricación mayores o iguales a 1983, donde el eje de las $x$ represente los años y el eje $y$, la velocidad crucero promedio a mph

```{r}
ggplot(data = filter1, mapping = aes (x = factor(year), y = speed)) +
  geom_boxplot() +labs(x= "Año de fabricación", y = "Velocidad crucero promedio (mph)")
```

Acotamos el numero de columnas del dataframe filtrado por ``año >= 1983`` con tal de que tenga solo la información que nos interesa

```{r}
df1 <- data.frame(year = filter1$year, speed =filter1$speed)
df1
```

Mandamos llamar sólo a la columna que corresponde a los años, Observamos que hay años que aparecen más de una vez. Además, creamos un factor a partir del vector df1 (años) y aPlicamos la función ``levels()`` para que regrese los años únicos

```{r}
# mandamos a llamar a la columna correspondiente de los años
df1$year

# creamos un factor y aplicamos la función levels
niv <- levels(factor(df1$year))
niv
```

Como la funcion level nos regresa un vector con entradas de tipo ``<char>`` Usamos ``lapply`` para aplicar a cada entrada del vector una funcion que convierta los ``<char>`` en ``<int>``. Notemos que ``lapply()`` regresa una LISTA con entradas tipo ``<int>``


```{r}
niv1 <- lapply(niv, as.integer)
niv1
```


Luego:

* Crear un dataframe vacio ``df3 <- data.frame()``.
* Creamos un ciclo ``for`` tal que, para cada año en la lista de años únicos ``niv1``.
* creamos un nuevo dataframe que filtre el dataframe acotado ``df1`` para que solonos regrese las velocidades asociadas a ese año particular.
* Estando en ese nuevo dataframe acotado y filtrado por años, calculamos la varianza de los valores de velocidad y la guardamos en la variable ``i``.
* Le pediremos que elimine del cálculo los valores ``NA``.
* Creamos un vector que incluya el año por el que estamos filtrando, la mediana de las velocidades de ese año y la varianza de ese año almacenada en ``i`` (para esta iteración).
* Pegamos ese vector como un nuevo renglón del dataframe vacio ``df3``
# Reescribimos sobre ``df3`` para que guarde los registros de cada iteración.

Lo anterior se traduce en código como


```{r}
# Dataframe vacío
df3 <- data.frame()

# ciclo form
for(fecha in niv1){
  filtro <- df1 %>%
    filter(year == fecha)
  i <- var(filtro$speed, na.rm = TRUE)
  df3 <- rbind(df3,c(fecha,median(filtro$speed, na.rm = TRUE),i))
}

# Mandamos llamar a df3 para verificar los registros
df3
```

continuando

```{r}
# Renombramos las columnas de df3 para que reflejen lo que almacenan
colnames(df3) <- c("año","mediana","varianza")

# Ordenamos sobre la varianza de forma desc a df3 y guardamos en un nuevo 
# dataframe df4
df4 <- df3[order(df3[,3], decreasing = TRUE),]

# Almacenamos en dataframe df5 sólo los primeros 4 registros con mayor varianza
df5 <- df4[1:4,]

# Ordenamos sobre mediana de forma desc a df5 y guardamos en dataframe df6
df6 <- df5[order(df5[,2], decreasing = TRUE),]
```


Finalmente, guardamos en una nueva variable solo los años ordenados sobre mediana de forma desc

```{r}
inciso_d <- df6[,1]

# Veamos el resultado final buscado en este inciso

print("De las 4 cajas con más registros, los años de mayor mediana en la velocidad, en orden descendiente son:")
inciso_d
```

### Inciso e) <a id="ie"></a>

Buscamos el máximo valor de la columna varianza en el dataframe ``df6`` 

```{r}
max(df6[,3])
```


Guardamos en un dataframe ``df7`` un filtro de ``df6`` tal que busque el máximo valor de varianza en la tercera columna de ``df6``y guardamos sólo la(s) coincidencia(s)

```{r}
df7 <- df6 %>%
filter(df6[,3]==max(df6[,3]))
df7
```

teniendo así como resultado final

```{r}
print(paste("El año con mayor varianza es",df7[1,1],"."))
```

### Inciso f) <a id="if"></a>

Filtramos los datos deseados 

```{r}
Aviones_BOEING<- planes %>%
  filter(manufacturer == "BOEING") 
glimpse(Aviones_BOEING)
```


Ahora procederemos a usar la funcion stem para realizar el diagrama de tallo y hojas

```{r}
Asientos <-Aviones_BOEING$seats
inciso_f <- stem(Asientos)
```


### Inciso g) <a id="ig"></a>

_i)_ Procedemos a sacar el Rango muestral o Rango

```{r}
max(Aviones_BOEING$seats)-min(Aviones_BOEING$seats)
```

_ii)_ y _iii)_ Para ello

```{r}
# Media
esp <- mean(Aviones_BOEING$seats)

#Continuamos con la  varianza y la desviacion estandar
varian <-var(Aviones_BOEING$seats)
desvi_estan <-sd(Aviones_BOEING$seats)
```

de donde

```{r}
paste("Media:", esp, "Varianza:",varian,"Desviación est:",desvi_estan)
```

_iv)_  Procedemos con os cuartiles y el rango intercuartil.

```{r}
# Cuartiles

quantile(Aviones_BOEING$seats, 0.25) 

quantile(Aviones_BOEING$seats, 0.75)
```

y el rango intercuantil

```{r}
IQR(Aviones_BOEING$seats)
```

o, alternativamente

```{r}
quantile(Aviones_BOEING$seats, 0.75)-quantile(Aviones_BOEING$seats, 0.25) 
```

_v)_  El sesgo y su interpretación, para ello debemos cargar el paquete ``e1071``, una vez hecho procedemos.

```{r message=FALSE, warning=FALSE}
library(e1071)
```

Comenzamos con el sesgo

```{r}
sesgo <- skewness(Aviones_BOEING$seats)
```

y para la interpretación correspondiente creamos la siguiente función

```{r}
fun_sesgo <- function(x){
  if(x>0){
  var <- "existen muchos valores en la muestra que son mayores que la media, i.e.,la distribución estÃ¡ concentrada a la izquierda"
  }
  else if(x<0){
  var <- "existen muchos valores en la muestra que son menores que la media, i.e.,la distribución está concentrada a la derecha"
  }
  print(paste("El sesgo es:",x))
  print(paste("Implica que",var))
}

# de modo que 
fun_sesgo(sesgo)
```

_vi)_ La curtosis y su interpretacion. De manera análoga al inciso anterior,, escribimos

```{r}
  kurtosis <-  kurtosis(Aviones_BOEING$seats)
  
  fun_kurt <- function(x){
    if(x>0){
      var <- "Es leptocúrtica, i.e., presenta decaimiento rápido con colas ligeras."
    }
    else if(x==0){
      var <- "Es mesocúrtica, i.e., es la curva normal."
    }
    else{
      var <- "Es platicúrtica, i.e., tiene decaimiento rápido y colas amplias."
    }
    print(paste("La kurtosis es:",x))
    print(var)
  }
  
# Para finalmente obtener
fun_kurt(kurtosis)
```


## Pregunta 2: Escriba una función que se llame _truncar_ como se especifica en la tarea. <a id="p2"></a>

_Solución:_ 

* Utilizaremos la función predefinida ``as.integer()`` para extraer la parte entera de un número. Así, al efectuar la diferencia entre el número y su parte entera obtendremos los decimales de dicho número, por ejemplo $2.5421 - 2 =0.5421$. Luego, de acuerdo al número de decimales que queramos mostrar, digamos $k$, entonces multiplicaremos dicha diferencia por $10^k$. Por ejemplo, supongamos que queremos mostrar dos decimales de $2.5421$ (es decir, mostrar el número $2.54$), por lo que consideraremos $0.5421 \cdot 10^2=54.21$ (es decir ``x <- (2.5421-as.integer(2.5421)) * 10 ** 2``) y a este resultado nuevamente le obtendremos su parte entera con ``as.integer(x)``.  Lo anterior nos arrojará $54$ de modo que, para obtener el resultado buscado, bastará con efectuar $2 + \frac{54}{100}=2+\frac{54}{10^2}=2.54$, es decir ``as.integer(2.5421) + as.integer(x / 10 ** 2)``. 

* Para el caso en que el número decimal tenga como parte entera el cero, por ejemplo el $0.1416$, bastará con multiplicar ese número por $10^k$, donde $k$ es el número de decimales que queremos mostrar, digamos $k=3$. Entonces tendremos $0.1416 \cdot 10^3=141.6$ al cual le obtendremos su parte entera y después dividiremos entre $10^3$ para tener que $\frac{141}{10^3}=0.141$.

Ahora, en código tendríamos que


```{r}

# Definimos la función truncar
truncar <- function(num, k){
  
  # Condicionamos a que k sea no negativo
  if (k < 0){
    
    print("El número de decimales debe ser un número entero no negativo")
    
  } else {
    
    # Definimos una variable como la parte entera de num
    num_int = as.integer(num)
    
    # Controlamos los casos en que num sea un decimal con parte entera distinta de cero
    
    if (num_int != 0){ 
      x = (num - num_int ) * 10 ** k 
      y = as.integer(x) / 10 ** k 
      z = num_int + y
      
      return(z)
      
    } else {
      
      # Caso en que la parte entera de num es cero
      
      y = as.integer(num * 10 ** k) / 10 ** k
      return(y)
      
    }
  }
}
```

Probamos la función

```{r}
# Ponemos lo siguiente para permitir que r muestre, según sea el caso, hasta 10 decimales de un número
options(digits = 11)

truncar(pi,10)
truncar(exp(1),-7)
truncar(-97.3028101, 5)
```

## Pregunta 3: Realice una función que simule el juego del Monthy Hall: <a id="p3"></a>

_Solución:_

La función que crearemos no tendrá argumentos pues el número de la puerta con la que se jugará será asignada por el presentador. Además, asignaremos de manera aleatoria el número entero entre 1 y 3 de la puerta que contiene el Mazda 2, así como el número de puerta que le corresponde al jugador. Así

* crearemos un vector aleatorio (digamos ``num_aleatorios``) de 9 entradas (con los números 1,2 y 3) con repetición para permitir que el número de la puerta aleatoria pueda coincidir con el número de puerta asignado al jugador

* creamos 3 variables auxiliares para determinar el número de la(s) puerta(s) restante(s)

* Si el número de puerta del jugador resulta ser la ganadora, entonces tendremos que asignar un número distinto (entre 1,2 y 3) a las dos puertas restantes, asignando a la primera puerta restante un número del vector aleatorio ``num_aleatorios`` distinto del número de la puerta ganadora; luego, para la segunda puerta restante utilizaremos el mismo procedimiento salvo que agregaremos que el número escogido de ``num_aleatorios`` sea distinto del número de la puerta ganadora y distinto del número de la primera puerta restante.

* si el jugador pierde, entonces tendremos inicialmente dos puertas asignadas con números distintos, de tal manera, en este caso, sólo debemos asignar adicionalmente el número de la puerta restante (la no ganadora y la que no es del jugador)

* finalmente, en esta parte, probamos si el código funciona para ver si el jugador gana o pierde 

```{r }
Monthy_Hall <- function() {
  # Vector con 9 entradas con los números enteros del 1 al 3 
  num_aleatorios = sample(1:3, 9, replace = T)
  
  # Número que contiene el Mazda 2 en esta ronda de juego 
  num_ganador = num_aleatorios[2]
  
  # Asignamos el número de la puerta que le corresponde al jugador en esta ronda
  num_puerta = num_aleatorios[3]
  
  # Le decimos al jugador qué puerta le tocó
  print(paste("Te ha tocado la puerta número:", num_puerta))
  
  # Variables auxiliares
  num_puerta_rest1 = 0
  num_puerta_rest2 = 0
  num_puerta_rest3 = 0
  
  # Número de puertas restantes para el caso en que el jugador gana
  if (num_puerta == num_ganador){
    
    # Asignación del número de la primera puerta restante
    for (i in num_aleatorios){
      if (i != num_puerta){
        num_puerta_rest1 = i
      }
    }
    
    # Asignación del número de la segunda puerta restante
    for (i in num_aleatorios){
      if (i != num_puerta & i!=num_puerta_rest1){
        num_puerta_rest2 = i
      }
    }
  } 
  
  # Número de la puerta restante para el caso en que el jugador pierde
  else {
    for (i in num_aleatorios){
      if (i != num_puerta & i!=num_ganador){
        num_puerta_rest3 = i
      }
    }
  }
  
  # Hacemos algunas pruebas....
  if (num_puerta == num_ganador){
    print(paste("El jugador ha ganado con el número de puerta:", num_puerta))
    print(paste("Puerta con una corona:", num_puerta_rest1))
    print(paste("Puerta con otra corona:", num_puerta_rest2))
    
  } else {

    print(paste("Número de puerta del jugador:", num_puerta))
    print(paste("Número de puerta ganadora:", num_ganador))
    print(paste("Puerta restante con una corona", num_puerta_rest3))
  }
}


# Invocamos la función antes creada
Monthy_Hall()
```

siendo así que, en este caso, el jugador pierde.

* Lo que sigue será destapar una puerta que el presentador sabe que tiene una corona. Será necesario considerar los casos: el jugador gana o el jugador pierde. Si el jugador gana, podemos destapar cualquiera de las dos puertas ``num_puerta_rest1`` o ``num_puerta_rest2``; si el jugador pierde debemos destapar la puerta ``num_puerta_rest3``.

```{r eval=FALSE}

  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función

  # El presentador destapa una puerta
  if (num_puerta == num_ganador){
    print(paste("La puerta número", num_puerta_rest1, " contiene una deliciosa corona cero"))
  } else {
    print(paste("La puerta número", num_puerta_rest3, " contiene una deliciosa corona cero"))
  }
}
```

* Simulamos como si el presentador preguntara al jugador si desea cambiar de puerta. Notemos que, si el jugador había elegido al principio la puerta ganadora y si decide cambiar de puerta, entonces necesariamente cambiará al número de puerta almacenado en ``num_puerta_rest2`` pues ya mostramos el contenido de la puerta con número ``num_puerta_rest1``. Si el jugador había elegido la puerta no ganadora, entonces ya mostramos el contenido de la puerta con número almacenado en ``num_puerta_rest3``, por lo que, si el jugador decide cambiar de puerta, entonces necesariamente cambiará a la puerta ganadora.

```{r eval=FALSE}

  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función

  # El presentador pregunta al jugador si desea cambiar de puerta
  respuesta = askYesNo(msg = "¿Desea cambiar de puerta?")

  # Damos un mensaje
  if (respuesta) {
    print("Haz cambiado de número de puerta, ¡perfecto!")
  } else {
    print("¡Bien! no haz cambiado de número de puerta, continuemos")
  }

  if (num_puerta == num_ganador){
    # Si el jugador cambia de puerta, entonces cambiará necesariamente al número 
    # de puerta en num_puerta_rest2, pues ya mostramos anteriormente el contenido
    # de la puerta con número almacenado en num_puerta_rest1
    
    if(respuesta){
      num_puerta = num_puerta_rest2
    }
  } else {
    # Si el jugador cambia de puerta, entonces cambiará necesariamente a la puerta
    # ganadora pues, en este caso, ya mostramos el contenido de la puerta con 
    # número almacenado en num_puerta_rest3
    
    if (respuesta){
      num_puerta = num_ganador
    }
  }
}
```

* Para finalizar el presentador mostrará la puerta ganadora y le dirá al jugador si gano o perdió

```{r eval=FALSE}

  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función
  # . Código anterior de la función

  # El jugador sabrá si ganó o perdió
  print("Procedamos a destapar la puerta ganadora....")

  if (num_puerta == num_ganador){
    print(paste("La puerta ganadora es:", num_puerta, "¡felicidades, has ganado!"))
  }
  else {
    print(paste("La puerta ganadora tiene el número:", num_ganador, "lamentablemente haz perdido"))
  }
}
```


---

El código completo de la función queda como 

```{r}

Monthy_Hall <- function() {
  # Vector con 9 entradas con los números enteros del 1 al 3 
  num_aleatorios = sample(1:3, 9, replace = T)
  
  # Número que contiene el Mazda 2 en esta ronda de juego 
  num_ganador = num_aleatorios[2]
  
  # Asignamos el número de la puerta que le corresponde al jugador en esta ronda
  num_puerta = num_aleatorios[3]
  
  # Le decimos al jugador qué puerta le tocó
  print(paste("Te ha tocado la puerta número:", num_puerta))
  
  # Variables auxiliares
  num_puerta_rest1 = 0
  num_puerta_rest2 = 0
  num_puerta_rest3 = 0
  
  # Número de puertas restantes para el caso en que el jugador gana
  if (num_puerta == num_ganador){
    
    # Asignación del número de la primera puerta restante
    for (i in num_aleatorios){
      if (i != num_puerta){
        num_puerta_rest1 = i
      }
    }
    
    # Asignación del número de la segunda puerta restante
    for (i in num_aleatorios){
      if (i != num_puerta & i!=num_puerta_rest1){
        num_puerta_rest2 = i
      }
    }
  } 
  
  # Número de la puerta restante para el caso en que el jugador pierde
  else {
    for (i in num_aleatorios){
      if (i != num_puerta & i!=num_ganador){
        num_puerta_rest3 = i
      }
    }
  }
  
  # El presentador destapa una puerta
  
  print("Veamos el contenido de una de las puertas....")
  
  if (num_puerta == num_ganador){
    print(paste("La puerta número", num_puerta_rest1, "contiene una deliciosa corona cero"))
  } else {
    print(paste("La puerta número", num_puerta_rest3, "contiene una deliciosa corona cero"))
  }
  
  # El presentador pregunta al jugador si desea cambiar de puerta
  respuesta = askYesNo(msg = "¿Desea cambiar de puerta?")
  
  # Damos un mensaje
  if (respuesta) {
    print("Haz cambiado de número de puerta, ¡perfecto!")
  } else {
    print("¡Bien! no haz cambiado de número de puerta, continuemos")
  }

  if (num_puerta == num_ganador){
    # Si el jugador cambia de puerta, entonces cambiará necesariamente al número 
    # de puerta en num_puerta_rest2, pues ya mostramos anteriormente el contenido
    # de la puerta con número almacenado en num_puerta_rest1
    
    
    if(respuesta){
      num_puerta = num_puerta_rest2
      print(paste("Ahora, tu número de puerta es:", num_puerta))
    }
  } else {
    # Si el jugador cambia de puerta, entonces cambiará necesariamente a la puerta
    # ganadora pues, en este caso, ya mostramos el contenido de la puerta con 
    # número almacenado en num_puerta_rest3
    
    if (respuesta){
      num_puerta = num_ganador
      print(paste("Ahora, tu número de puerta es:", num_puerta))
    }
  }
  
  # El jugador sabrá si ganó o perdió
  print("Procedamos a destapar la puerta ganadora....")

  if (num_puerta == num_ganador){
    print(paste("La puerta ganadora es:", num_ganador, "¡felicidades, has ganado!"))
  }
  else {
    print(paste("La puerta ganadora es la número", num_ganador, "lamentablemente haz perdido"))
  }
}
```


Finalmente probamos el código

```{r}
Monthy_Hall()
```



